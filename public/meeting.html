// SDP Utils for handling media sections
const SDPUtils = {
    getMediaSections(sdp) {
        const sections = sdp.split('\nm=');
        return sections.map((section, index) => {
            return index > 0 ? 'm=' + section : section;
        });
    },

    getMid(section) {
        const midMatch = section.match(/\na=mid:(.*)/);
        return midMatch ? midMatch[1] : null;
    },

    reorderSDP(sdp, order) {
        const sections = this.getMediaSections(sdp);
        const header = sections[0];
        const media = sections.slice(1);
        
        // Create ordered media sections based on the provided order
        const orderedMedia = order.map(mid => {
            return media.find(section => this.getMid(section) === mid);
        }).filter(Boolean);
        
        return [header, ...orderedMedia].join('\n');
    }
};

socket.on('offer', async ({ offer, from, fromUser }) => {
    console.log('üì§ Received offer from:', fromUser || from);

    try {
        let peerConnection = peerConnections.get(from);
        if (!peerConnection) {
            peerConnection = createPeerConnection(from, fromUser);
        }

        // Store the current transceivers order before setting remote description
        const currentTransceivers = peerConnection.getTransceivers();
        const currentOrder = currentTransceivers.map(t => t.mid);

        // If we have existing transceivers, ensure they match the incoming offer
        if (currentTransceivers.length > 0) {
            const offerSdp = new RTCSessionDescription(offer);
            const sections = SDPUtils.getMediaSections(offerSdp.sdp);
            
            // Reorder transceivers to match the offer if needed
            sections.forEach((section, idx) => {
                const mid = SDPUtils.getMid(section);
                const transceiver = currentTransceivers.find(t => t.mid === mid);
                if (transceiver && transceiver.mid !== currentOrder[idx]) {
                    // Swap positions to match offer order
                    const currentIdx = currentOrder.indexOf(transceiver.mid);
                    [currentOrder[currentIdx], currentOrder[idx]] = [currentOrder[idx], currentOrder[currentIdx]];
                }
            });
        }

        console.log('üì§ Setting remote description...');
        await peerConnection.setRemoteDescription(offer);

        console.log('üì§ Creating answer...');
        const answer = await peerConnection.createAnswer();

        // Ensure answer maintains the same m-line order
        const modifiedAnswer = new RTCSessionDescription({
            type: 'answer',
            sdp: answer.sdp
        });

        console.log('üì§ Setting local description...');
        await peerConnection.setLocalDescription(modifiedAnswer);

        console.log('üì§ Sending answer to:', fromUser);
        socket.emit('answer', {
            answer: modifiedAnswer,
            to: from
        });

    } catch (error) {
        console.error('‚ùå Error handling offer:', error);
        
        // Attempt recovery if it's an InvalidAccessError
        if (error.name === 'InvalidAccessError') {
            try {
                console.log('üîÑ Attempting connection recovery...');
                
                // Close existing connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnections.delete(from);
                }
                
                // Create new connection with fresh state
                const newPeerConnection = createPeerConnection(from, fromUser);
                
                // Set remote description on new connection
                await newPeerConnection.setRemoteDescription(offer);
                
                // Create and send new answer
                const newAnswer = await newPeerConnection.createAnswer();
                await newPeerConnection.setLocalDescription(newAnswer);
                
                socket.emit('answer', {
                    answer: newAnswer,
                    to: from
                });
                
                console.log('‚úÖ Connection recovery successful');
            } catch (recoveryError) {
                console.error('‚ùå Connection recovery failed:', recoveryError);
                showNotification('Failed to establish connection after recovery attempt', 'error');
            }
        } else {
            showNotification('Failed to establish connection', 'error');
        }
    }
});

socket.on('answer', async ({ answer, from, fromUser }) => {
    console.log('üì• Received answer from:', fromUser || from);

    try {
        const peerConnection = peerConnections.get(from);
        if (!peerConnection) {
            console.error('‚ùå No peer connection found for:', from);
            return;
        }

        // Check connection state and readiness
        if (peerConnection.signalingState === 'stable') {
            console.warn('‚ö†Ô∏è Connection already in stable state, ignoring answer');
            return;
        }

        if (!peerConnection.remoteDescription) {
            console.log('üì• Setting remote description from answer...');
            
            // Ensure the answer has the correct type
            const modifiedAnswer = new RTCSessionDescription({
                type: 'answer',
                sdp: answer.sdp
            });

            // Verify m-line order matches the offer
            const offerSections = SDPUtils.getMediaSections(peerConnection.localDescription.sdp);
            const answerSections = SDPUtils.getMediaSections(modifiedAnswer.sdp);

            if (offerSections.length === answerSections.length) {
                // Reorder answer sections to match offer if needed
                const offerOrder = offerSections.map(section => SDPUtils.getMid(section));
                const reorderedSDP = SDPUtils.reorderSDP(modifiedAnswer.sdp, offerOrder);
                modifiedAnswer.sdp = reorderedSDP;
            }

            await peerConnection.setRemoteDescription(modifiedAnswer);
            console.log('‚úÖ Answer processed successfully');

            // After setting remote description, check ICE connection
            if (peerConnection.iceConnectionState === 'failed') {
                console.log('üîÑ ICE connection failed after answer, attempting recovery...');
                await handleIceFailure(peerConnection, from, fromUser);
            }
        } else {
            console.warn('‚ö†Ô∏è Remote description already set, ignoring answer');
        }
    } catch (error) {
        console.error('‚ùå Error handling answer:', error);
        
        if (error.name === 'InvalidStateError') {
            try {
                console.log('üîÑ Attempting to recover from invalid state...');
                const peerConnection = peerConnections.get(from);
                
                // Close and recreate connection
                if (peerConnection) {
                    peerConnection.close();
                    peerConnections.delete(from);
                }
                
                // Create new connection and send fresh offer
                const newPeerConnection = createPeerConnection(from, fromUser);
                const offer = await newPeerConnection.createOffer();
                await newPeerConnection.setLocalDescription(offer);
                
                socket.emit('offer', {
                    offer: offer,
                    to: from
                });
                
                console.log('‚úÖ Connection recovery initiated');
            } catch (recoveryError) {
                console.error('‚ùå Recovery attempt failed:', recoveryError);
                showNotification('Connection recovery failed, please try rejoining', 'error');
            }
        }
    }
});

function createPeerConnection(socketId, participantEmail = 'Participant') {
    console.log('ü§ù Creating peer connection for:', participantEmail);

    const peerConnection = new RTCPeerConnection(configuration);

    // Add transceivers in a consistent order
    peerConnection.addTransceiver('audio', {
        direction: 'sendrecv',
        streams: localStream ? [localStream] : []
    });
    peerConnection.addTransceiver('video', {
        direction: 'sendrecv',
        streams: localStream ? [localStream] : []
    });

    // Add local tracks if available
    if (localStream) {
        localStream.getTracks().forEach(track => {
            console.log('üì§ Adding local track:', track.kind, 'to peer:', participantEmail);
            // Use existing transceivers instead of creating new ones
            const transceiver = peerConnection.getTransceivers().find(t => 
                t.sender.track === null && t.receiver.track.kind === track.kind
            );
            if (transceiver) {
                transceiver.sender.replaceTrack(track);
            }
        });
    }

    peerConnection.ontrack = (event) => {
        console.log('üì• Received remote track:', event.track.kind, 'from:', participantEmail);
        const [remoteStream] = event.streams;

        if (remoteStream) {
            // Set audio output device if available
            if (typeof event.track.applyConstraints === 'function') {
                event.track.applyConstraints({
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }).catch(e => console.warn('Could not apply constraints:', e));
            }

            console.log('‚úÖ Remote stream received, adding participant:', participantEmail);
            addRemoteParticipant(socketId, remoteStream, participantEmail);
        }
    };

    // Enhanced connection state handling
    peerConnection.onconnectionstatechange = () => {
        const state = peerConnection.connectionState;
        console.log(`üîó Connection state with ${participantEmail}:`, state);

        switch (state) {
            case 'connected':
                showNotification(`Connected to ${participantEmail}`);
                // Optimize after connection
                peerConnection.getReceivers().forEach(receiver => {
                    if (receiver.track.kind === 'video') {
                        receiver.track.contentHint = 'motion';
                    }
                });
                break;
            case 'disconnected':
                showNotification(`Disconnected from ${participantEmail}`, 'warning');
                attemptReconnection(peerConnection, socketId, participantEmail);
                break;
            case 'failed':
                console.log('üîÑ Connection failed, attempting recovery...');
                handleConnectionFailure(peerConnection, socketId, participantEmail);
                break;
        }
    };

    // Enhanced ICE handling
    peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
            // Prioritize candidates with higher bandwidth
            const candidateString = event.candidate.candidate.toLowerCase();
            if (candidateString.includes('tcp') || 
                candidateString.includes('relay') || 
                candidateString.includes('ssltcp')) {
                event.candidate.priority = 1;
            }
            socket.emit('ice-candidate', {
                candidate: event.candidate,
                to: socketId
            });
        }
    };

    peerConnection.oniceconnectionstatechange = () => {
        const state = peerConnection.iceConnectionState;
        console.log(`üßä ICE connection state with ${participantEmail}:`, state);

        if (state === 'failed' || state === 'disconnected') {
            console.log('üîÑ ICE connection issues, attempting recovery...');
            handleIceFailure(peerConnection, socketId, participantEmail);
        }
    };

    peerConnections.set(socketId, peerConnection);
    return peerConnection;
}

// Connection recovery functions
async function attemptReconnection(peerConnection, socketId, participantEmail) {
    try {
        console.log('üîÑ Attempting to reconnect with:', participantEmail);
        await peerConnection.restartIce();
        
        // Create and send new offer
        const offer = await peerConnection.createOffer({ iceRestart: true });
        await peerConnection.setLocalDescription(offer);
        
        socket.emit('offer', {
            offer: offer,
            to: socketId
        });
    } catch (error) {
        console.error('‚ùå Reconnection attempt failed:', error);
    }
}

async function handleConnectionFailure(peerConnection, socketId, participantEmail) {
    try {
        console.log('üîÑ Handling connection failure for:', participantEmail);
        
        // Close existing connection
        peerConnection.close();
        peerConnections.delete(socketId);
        
        // Create new connection
        const newPeerConnection = createPeerConnection(socketId, participantEmail);
        
        // Create and send new offer
        const offer = await newPeerConnection.createOffer();
        await newPeerConnection.setLocalDescription(offer);
        
        socket.emit('offer', {
            offer: offer,
            to: socketId
        });
    } catch (error) {
        console.error('‚ùå Connection failure recovery failed:', error);
    }
}

async function handleIceFailure(peerConnection, socketId, participantEmail) {
    try {
        console.log('üßä Handling ICE failure for:', participantEmail);
        
        // Try to restart ICE
        const offer = await peerConnection.createOffer({ iceRestart: true });
        await peerConnection.setLocalDescription(offer);
        
        socket.emit('offer', {
            offer: offer,
            to: socketId
        });
    } catch (error) {
        console.error('‚ùå ICE failure recovery failed:', error);
        handleConnectionFailure(peerConnection, socketId, participantEmail);
    }
}

.main-participant-name {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 16px;
    border-radius: 20px;
    font-size: 16px;
    font-weight: 500;
    z-index: 5;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.connection-status {
    position: absolute;
    top: 12px;
    right: 12px;
    padding: 6px 12px;
    border-radius: 16px;
    font-size: 11px;
    background: rgba(0, 0, 0, 0.8);
    z-index: 5;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.notification {
    position: fixed;
    top: 24px;
    left: 50%;
    transform: translateX(-50%) translateY(-120px);
    background: rgba(60, 64, 67, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    color: white;
    padding: 16px 24px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1001;
    max-width: 400px;
    text-align: center;
    font-weight: 500;
}

.fullscreen-btn {
    position: absolute;
    top: 24px;
    right: 24px;
    background: rgba(0, 0, 0, 0.8);
    border: none;
    color: white;
    padding: 12px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    z-index: 10;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.camera-rotate-btn {
    background: rgba(0, 0, 0, 0.8);
    border: none;
    color: white;
    padding: 8px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 16px;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.watermark {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: linear-gradient(135deg, #1a73e8, #4285f4);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 14px;
    font-weight: 600;
    z-index: 5;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    box-shadow: 0 4px 12px rgba(26, 115, 232, 0.3);
    letter-spacing: 1px;
    user-select: none;
    -webkit-user-select: none;
    pointer-events: none;
}

.status-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 16px 24px;
    border-radius: 12px;
    font-size: 15px;
    text-align: center;
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    z-index: 10;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
} 
